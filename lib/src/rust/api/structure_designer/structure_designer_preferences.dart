// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../common_api_types.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `default_auto_layout_after_edit`, `default_background_color`, `default_ball_and_stick_cull_depth`, `default_drawing_plane_grid_color`, `default_drawing_plane_grid_strong_color`, `default_grid_color`, `default_grid_size`, `default_grid_strong_color`, `default_lattice_grid_color`, `default_lattice_grid_strong_color`, `default_samples_per_unit_cell`, `default_sharpness_angle_threshold`, `default_show_axes`, `default_show_grid`, `default_show_lattice_axes`, `default_space_filling_cull_depth`, `default_true`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`

enum AtomicRenderingMethod {
  triangleMesh,
  impostors,
  ;

  static Future<AtomicRenderingMethod> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesAtomicRenderingMethodDefault();
}

enum AtomicStructureVisualization {
  ballAndStick,
  spaceFilling,
  ;

  static Future<AtomicStructureVisualization> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesAtomicStructureVisualizationDefault();
}

class AtomicStructureVisualizationPreferences {
  AtomicStructureVisualization visualization;
  AtomicRenderingMethod renderingMethod;
  double? ballAndStickCullDepth;
  double? spaceFillingCullDepth;

  AtomicStructureVisualizationPreferences({
    required this.visualization,
    required this.renderingMethod,
    this.ballAndStickCullDepth,
    this.spaceFillingCullDepth,
  });

  static Future<AtomicStructureVisualizationPreferences> default_() => RustLib
      .instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesAtomicStructureVisualizationPreferencesDefault();

  @override
  int get hashCode =>
      visualization.hashCode ^
      renderingMethod.hashCode ^
      ballAndStickCullDepth.hashCode ^
      spaceFillingCullDepth.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AtomicStructureVisualizationPreferences &&
          runtimeType == other.runtimeType &&
          visualization == other.visualization &&
          renderingMethod == other.renderingMethod &&
          ballAndStickCullDepth == other.ballAndStickCullDepth &&
          spaceFillingCullDepth == other.spaceFillingCullDepth;
}

class BackgroundPreferences {
  APIIVec3 backgroundColor;
  bool showAxes;
  bool showGrid;
  int gridSize;
  APIIVec3 gridColor;
  APIIVec3 gridStrongColor;
  bool showLatticeAxes;
  bool showLatticeGrid;
  APIIVec3 latticeGridColor;
  APIIVec3 latticeGridStrongColor;
  APIIVec3 drawingPlaneGridColor;
  APIIVec3 drawingPlaneGridStrongColor;

  BackgroundPreferences({
    required this.backgroundColor,
    required this.showAxes,
    required this.showGrid,
    required this.gridSize,
    required this.gridColor,
    required this.gridStrongColor,
    required this.showLatticeAxes,
    required this.showLatticeGrid,
    required this.latticeGridColor,
    required this.latticeGridStrongColor,
    required this.drawingPlaneGridColor,
    required this.drawingPlaneGridStrongColor,
  });

  static Future<BackgroundPreferences> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesBackgroundPreferencesDefault();

  @override
  int get hashCode =>
      backgroundColor.hashCode ^
      showAxes.hashCode ^
      showGrid.hashCode ^
      gridSize.hashCode ^
      gridColor.hashCode ^
      gridStrongColor.hashCode ^
      showLatticeAxes.hashCode ^
      showLatticeGrid.hashCode ^
      latticeGridColor.hashCode ^
      latticeGridStrongColor.hashCode ^
      drawingPlaneGridColor.hashCode ^
      drawingPlaneGridStrongColor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackgroundPreferences &&
          runtimeType == other.runtimeType &&
          backgroundColor == other.backgroundColor &&
          showAxes == other.showAxes &&
          showGrid == other.showGrid &&
          gridSize == other.gridSize &&
          gridColor == other.gridColor &&
          gridStrongColor == other.gridStrongColor &&
          showLatticeAxes == other.showLatticeAxes &&
          showLatticeGrid == other.showLatticeGrid &&
          latticeGridColor == other.latticeGridColor &&
          latticeGridStrongColor == other.latticeGridStrongColor &&
          drawingPlaneGridColor == other.drawingPlaneGridColor &&
          drawingPlaneGridStrongColor == other.drawingPlaneGridStrongColor;
}

enum GeometryVisualization {
  surfaceSplatting,
  explicitMesh,
  ;

  static Future<GeometryVisualization> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesGeometryVisualizationDefault();
}

class GeometryVisualizationPreferences {
  GeometryVisualization geometryVisualization;
  bool wireframeGeometry;
  int samplesPerUnitCell;
  double sharpnessAngleThresholdDegree;
  MeshSmoothing meshSmoothing;
  bool displayCameraTarget;

  GeometryVisualizationPreferences({
    required this.geometryVisualization,
    required this.wireframeGeometry,
    required this.samplesPerUnitCell,
    required this.sharpnessAngleThresholdDegree,
    required this.meshSmoothing,
    required this.displayCameraTarget,
  });

  static Future<GeometryVisualizationPreferences> default_() => RustLib
      .instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesGeometryVisualizationPreferencesDefault();

  @override
  int get hashCode =>
      geometryVisualization.hashCode ^
      wireframeGeometry.hashCode ^
      samplesPerUnitCell.hashCode ^
      sharpnessAngleThresholdDegree.hashCode ^
      meshSmoothing.hashCode ^
      displayCameraTarget.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeometryVisualizationPreferences &&
          runtimeType == other.runtimeType &&
          geometryVisualization == other.geometryVisualization &&
          wireframeGeometry == other.wireframeGeometry &&
          samplesPerUnitCell == other.samplesPerUnitCell &&
          sharpnessAngleThresholdDegree ==
              other.sharpnessAngleThresholdDegree &&
          meshSmoothing == other.meshSmoothing &&
          displayCameraTarget == other.displayCameraTarget;
}

/// Layout algorithm preference for full network auto-layout operations.
///
/// These algorithms reorganize the entire network. They are used:
/// - When "Auto-Layout Network" is triggered from the menu
/// - After AI edit operations (when auto_layout_after_edit is enabled)
///
/// Note: Incremental positioning of new nodes during editing is handled
/// separately by the auto_layout module, not through this enum.
enum LayoutAlgorithmPreference {
  /// Simple layered layout based on topological depth. Fast and reliable.
  /// Organizes nodes into columns by their depth in the dependency graph.
  topologicalGrid,

  /// Sophisticated layered layout with crossing minimization.
  /// Uses the Sugiyama algorithm for better visual quality on complex graphs.
  sugiyama,
  ;

  static Future<LayoutAlgorithmPreference> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesLayoutAlgorithmPreferenceDefault();
}

/// Preferences for auto-layout operations.
class LayoutPreferences {
  /// The layout algorithm to use for auto-layout operations.
  LayoutAlgorithmPreference layoutAlgorithm;

  /// Whether to automatically apply layout after AI edit operations.
  /// When true, the full network layout is recomputed after each edit.
  /// When false, only new nodes are positioned incrementally.
  bool autoLayoutAfterEdit;

  LayoutPreferences({
    required this.layoutAlgorithm,
    required this.autoLayoutAfterEdit,
  });

  static Future<LayoutPreferences> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesLayoutPreferencesDefault();

  @override
  int get hashCode => layoutAlgorithm.hashCode ^ autoLayoutAfterEdit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LayoutPreferences &&
          runtimeType == other.runtimeType &&
          layoutAlgorithm == other.layoutAlgorithm &&
          autoLayoutAfterEdit == other.autoLayoutAfterEdit;
}

/// Enum to control mesh smoothing behavior during tessellation
enum MeshSmoothing {
  /// Smooth normals: averages normals at each vertex from all connected faces
  smooth,

  /// Sharp normals: uses face normals directly, duplicates vertices as needed
  sharp,

  /// Smoothing group based: averages normals within the same smoothing group,
  /// duplicates vertices at smoothing group boundaries
  smoothingGroupBased,
  ;

  static Future<MeshSmoothing> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesMeshSmoothingDefault();
}

enum NodeDisplayPolicy {
  manual,
  preferSelected,
  preferFrontier,
  ;

  static Future<NodeDisplayPolicy> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesNodeDisplayPolicyDefault();
}

class NodeDisplayPreferences {
  NodeDisplayPolicy displayPolicy;

  NodeDisplayPreferences({
    required this.displayPolicy,
  });

  static Future<NodeDisplayPreferences> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesNodeDisplayPreferencesDefault();

  @override
  int get hashCode => displayPolicy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeDisplayPreferences &&
          runtimeType == other.runtimeType &&
          displayPolicy == other.displayPolicy;
}

/// Preferences for energy minimization simulation.
class SimulationPreferences {
  /// Use spatial grid with distance cutoff for van der Waals interactions.
  /// When false, all nonbonded pairs are computed exactly (O(N^2)).
  /// When true (default), a 6 A cutoff is used for faster computation on large structures.
  bool useVdwCutoff;

  SimulationPreferences({
    required this.useVdwCutoff,
  });

  static Future<SimulationPreferences> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesSimulationPreferencesDefault();

  @override
  int get hashCode => useVdwCutoff.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SimulationPreferences &&
          runtimeType == other.runtimeType &&
          useVdwCutoff == other.useVdwCutoff;
}

class StructureDesignerPreferences {
  final GeometryVisualizationPreferences geometryVisualizationPreferences;
  final NodeDisplayPreferences nodeDisplayPreferences;
  final AtomicStructureVisualizationPreferences
      atomicStructureVisualizationPreferences;
  final BackgroundPreferences backgroundPreferences;
  final LayoutPreferences layoutPreferences;
  final SimulationPreferences simulationPreferences;

  const StructureDesignerPreferences.raw({
    required this.geometryVisualizationPreferences,
    required this.nodeDisplayPreferences,
    required this.atomicStructureVisualizationPreferences,
    required this.backgroundPreferences,
    required this.layoutPreferences,
    required this.simulationPreferences,
  });

  StructureDesignerPreferences cloneSelf() => RustLib.instance.api
          .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesCloneSelf(
        that: this,
      );

  static Future<StructureDesignerPreferences> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesDefault();

  factory StructureDesignerPreferences() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesNew();

  @override
  int get hashCode =>
      geometryVisualizationPreferences.hashCode ^
      nodeDisplayPreferences.hashCode ^
      atomicStructureVisualizationPreferences.hashCode ^
      backgroundPreferences.hashCode ^
      layoutPreferences.hashCode ^
      simulationPreferences.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StructureDesignerPreferences &&
          runtimeType == other.runtimeType &&
          geometryVisualizationPreferences ==
              other.geometryVisualizationPreferences &&
          nodeDisplayPreferences == other.nodeDisplayPreferences &&
          atomicStructureVisualizationPreferences ==
              other.atomicStructureVisualizationPreferences &&
          backgroundPreferences == other.backgroundPreferences &&
          layoutPreferences == other.layoutPreferences &&
          simulationPreferences == other.simulationPreferences;
}
