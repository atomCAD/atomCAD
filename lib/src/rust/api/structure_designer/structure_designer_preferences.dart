// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../common_api_types.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `from`

enum AtomicRenderingMethod {
  triangleMesh,
  impostors,
  ;
}

enum AtomicStructureVisualization {
  ballAndStick,
  spaceFilling,
  ;
}

class AtomicStructureVisualizationPreferences {
  AtomicStructureVisualization visualization;
  AtomicRenderingMethod renderingMethod;
  double? ballAndStickCullDepth;
  double? spaceFillingCullDepth;

  AtomicStructureVisualizationPreferences({
    required this.visualization,
    required this.renderingMethod,
    this.ballAndStickCullDepth,
    this.spaceFillingCullDepth,
  });

  @override
  int get hashCode =>
      visualization.hashCode ^
      renderingMethod.hashCode ^
      ballAndStickCullDepth.hashCode ^
      spaceFillingCullDepth.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AtomicStructureVisualizationPreferences &&
          runtimeType == other.runtimeType &&
          visualization == other.visualization &&
          renderingMethod == other.renderingMethod &&
          ballAndStickCullDepth == other.ballAndStickCullDepth &&
          spaceFillingCullDepth == other.spaceFillingCullDepth;
}

class BackgroundPreferences {
  APIIVec3 backgroundColor;
  bool showGrid;
  int gridSize;
  APIIVec3 gridColor;
  APIIVec3 gridStrongColor;
  bool showLatticeAxes;
  bool showLatticeGrid;
  APIIVec3 latticeGridColor;
  APIIVec3 latticeGridStrongColor;
  APIIVec3 drawingPlaneGridColor;
  APIIVec3 drawingPlaneGridStrongColor;

  BackgroundPreferences({
    required this.backgroundColor,
    required this.showGrid,
    required this.gridSize,
    required this.gridColor,
    required this.gridStrongColor,
    required this.showLatticeAxes,
    required this.showLatticeGrid,
    required this.latticeGridColor,
    required this.latticeGridStrongColor,
    required this.drawingPlaneGridColor,
    required this.drawingPlaneGridStrongColor,
  });

  @override
  int get hashCode =>
      backgroundColor.hashCode ^
      showGrid.hashCode ^
      gridSize.hashCode ^
      gridColor.hashCode ^
      gridStrongColor.hashCode ^
      showLatticeAxes.hashCode ^
      showLatticeGrid.hashCode ^
      latticeGridColor.hashCode ^
      latticeGridStrongColor.hashCode ^
      drawingPlaneGridColor.hashCode ^
      drawingPlaneGridStrongColor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackgroundPreferences &&
          runtimeType == other.runtimeType &&
          backgroundColor == other.backgroundColor &&
          showGrid == other.showGrid &&
          gridSize == other.gridSize &&
          gridColor == other.gridColor &&
          gridStrongColor == other.gridStrongColor &&
          showLatticeAxes == other.showLatticeAxes &&
          showLatticeGrid == other.showLatticeGrid &&
          latticeGridColor == other.latticeGridColor &&
          latticeGridStrongColor == other.latticeGridStrongColor &&
          drawingPlaneGridColor == other.drawingPlaneGridColor &&
          drawingPlaneGridStrongColor == other.drawingPlaneGridStrongColor;
}

enum GeometryVisualization {
  surfaceSplatting,
  explicitMesh,
  ;
}

class GeometryVisualizationPreferences {
  GeometryVisualization geometryVisualization;
  bool wireframeGeometry;
  int samplesPerUnitCell;
  double sharpnessAngleThresholdDegree;
  MeshSmoothing meshSmoothing;
  bool displayCameraTarget;

  GeometryVisualizationPreferences({
    required this.geometryVisualization,
    required this.wireframeGeometry,
    required this.samplesPerUnitCell,
    required this.sharpnessAngleThresholdDegree,
    required this.meshSmoothing,
    required this.displayCameraTarget,
  });

  @override
  int get hashCode =>
      geometryVisualization.hashCode ^
      wireframeGeometry.hashCode ^
      samplesPerUnitCell.hashCode ^
      sharpnessAngleThresholdDegree.hashCode ^
      meshSmoothing.hashCode ^
      displayCameraTarget.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeometryVisualizationPreferences &&
          runtimeType == other.runtimeType &&
          geometryVisualization == other.geometryVisualization &&
          wireframeGeometry == other.wireframeGeometry &&
          samplesPerUnitCell == other.samplesPerUnitCell &&
          sharpnessAngleThresholdDegree ==
              other.sharpnessAngleThresholdDegree &&
          meshSmoothing == other.meshSmoothing &&
          displayCameraTarget == other.displayCameraTarget;
}

/// Layout algorithm preference for full network auto-layout operations.
///
/// These algorithms reorganize the entire network. They are used:
/// - When "Auto-Layout Network" is triggered from the menu
/// - After AI edit operations (when auto_layout_after_edit is enabled)
///
/// Note: Incremental positioning of new nodes during editing is handled
/// separately by the auto_layout module, not through this enum.
enum LayoutAlgorithmPreference {
  /// Simple layered layout based on topological depth. Fast and reliable.
  /// Organizes nodes into columns by their depth in the dependency graph.
  topologicalGrid,

  /// Sophisticated layered layout with crossing minimization.
  /// Uses the Sugiyama algorithm for better visual quality on complex graphs.
  sugiyama,
  ;

  static Future<LayoutAlgorithmPreference> default_() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesLayoutAlgorithmPreferenceDefault();
}

/// Preferences for auto-layout operations.
class LayoutPreferences {
  /// The layout algorithm to use for auto-layout operations.
  LayoutAlgorithmPreference layoutAlgorithm;

  /// Whether to automatically apply layout after AI edit operations.
  /// When true, the full network layout is recomputed after each edit.
  /// When false, only new nodes are positioned incrementally.
  bool autoLayoutAfterEdit;

  LayoutPreferences({
    required this.layoutAlgorithm,
    required this.autoLayoutAfterEdit,
  });

  @override
  int get hashCode => layoutAlgorithm.hashCode ^ autoLayoutAfterEdit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LayoutPreferences &&
          runtimeType == other.runtimeType &&
          layoutAlgorithm == other.layoutAlgorithm &&
          autoLayoutAfterEdit == other.autoLayoutAfterEdit;
}

/// Enum to control mesh smoothing behavior during tessellation
enum MeshSmoothing {
  /// Smooth normals: averages normals at each vertex from all connected faces
  smooth,

  /// Sharp normals: uses face normals directly, duplicates vertices as needed
  sharp,

  /// Smoothing group based: averages normals within the same smoothing group,
  /// duplicates vertices at smoothing group boundaries
  smoothingGroupBased,
  ;
}

enum NodeDisplayPolicy {
  manual,
  preferSelected,
  preferFrontier,
  ;
}

class NodeDisplayPreferences {
  NodeDisplayPolicy displayPolicy;

  NodeDisplayPreferences({
    required this.displayPolicy,
  });

  @override
  int get hashCode => displayPolicy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeDisplayPreferences &&
          runtimeType == other.runtimeType &&
          displayPolicy == other.displayPolicy;
}

class StructureDesignerPreferences {
  final GeometryVisualizationPreferences geometryVisualizationPreferences;
  final NodeDisplayPreferences nodeDisplayPreferences;
  final AtomicStructureVisualizationPreferences
      atomicStructureVisualizationPreferences;
  final BackgroundPreferences backgroundPreferences;
  final LayoutPreferences layoutPreferences;

  const StructureDesignerPreferences.raw({
    required this.geometryVisualizationPreferences,
    required this.nodeDisplayPreferences,
    required this.atomicStructureVisualizationPreferences,
    required this.backgroundPreferences,
    required this.layoutPreferences,
  });

  StructureDesignerPreferences cloneSelf() => RustLib.instance.api
          .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesCloneSelf(
        that: this,
      );

  factory StructureDesignerPreferences() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesNew();

  @override
  int get hashCode =>
      geometryVisualizationPreferences.hashCode ^
      nodeDisplayPreferences.hashCode ^
      atomicStructureVisualizationPreferences.hashCode ^
      backgroundPreferences.hashCode ^
      layoutPreferences.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StructureDesignerPreferences &&
          runtimeType == other.runtimeType &&
          geometryVisualizationPreferences ==
              other.geometryVisualizationPreferences &&
          nodeDisplayPreferences == other.nodeDisplayPreferences &&
          atomicStructureVisualizationPreferences ==
              other.atomicStructureVisualizationPreferences &&
          backgroundPreferences == other.backgroundPreferences &&
          layoutPreferences == other.layoutPreferences;
}
