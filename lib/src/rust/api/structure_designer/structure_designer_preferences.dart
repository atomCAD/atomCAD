// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`

enum AtomicStructureVisualization {
  ballAndStick,
  spaceFilling,
  ;
}

class AtomicStructureVisualizationPreferences {
  AtomicStructureVisualization visualization;
  double? ballAndStickCullDepth;
  double? spaceFillingCullDepth;

  AtomicStructureVisualizationPreferences({
    required this.visualization,
    this.ballAndStickCullDepth,
    this.spaceFillingCullDepth,
  });

  @override
  int get hashCode =>
      visualization.hashCode ^
      ballAndStickCullDepth.hashCode ^
      spaceFillingCullDepth.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AtomicStructureVisualizationPreferences &&
          runtimeType == other.runtimeType &&
          visualization == other.visualization &&
          ballAndStickCullDepth == other.ballAndStickCullDepth &&
          spaceFillingCullDepth == other.spaceFillingCullDepth;
}

enum GeometryVisualization {
  surfaceSplatting,
  dualContouring,
  explicitMesh,
  ;
}

class GeometryVisualizationPreferences {
  GeometryVisualization geometryVisualization;
  bool wireframeGeometry;
  int samplesPerUnitCell;
  double sharpnessAngleThresholdDegree;
  MeshSmoothing meshSmoothing;
  bool displayCameraTarget;

  GeometryVisualizationPreferences({
    required this.geometryVisualization,
    required this.wireframeGeometry,
    required this.samplesPerUnitCell,
    required this.sharpnessAngleThresholdDegree,
    required this.meshSmoothing,
    required this.displayCameraTarget,
  });

  @override
  int get hashCode =>
      geometryVisualization.hashCode ^
      wireframeGeometry.hashCode ^
      samplesPerUnitCell.hashCode ^
      sharpnessAngleThresholdDegree.hashCode ^
      meshSmoothing.hashCode ^
      displayCameraTarget.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeometryVisualizationPreferences &&
          runtimeType == other.runtimeType &&
          geometryVisualization == other.geometryVisualization &&
          wireframeGeometry == other.wireframeGeometry &&
          samplesPerUnitCell == other.samplesPerUnitCell &&
          sharpnessAngleThresholdDegree ==
              other.sharpnessAngleThresholdDegree &&
          meshSmoothing == other.meshSmoothing &&
          displayCameraTarget == other.displayCameraTarget;
}

/// Enum to control mesh smoothing behavior during tessellation
enum MeshSmoothing {
  /// Smooth normals: averages normals at each vertex from all connected faces
  smooth,

  /// Sharp normals: uses face normals directly, duplicates vertices as needed
  sharp,

  /// Smoothing group based: averages normals within the same smoothing group,
  /// duplicates vertices at smoothing group boundaries
  smoothingGroupBased,
  ;
}

enum NodeDisplayPolicy {
  manual,
  preferSelected,
  preferFrontier,
  ;
}

class NodeDisplayPreferences {
  NodeDisplayPolicy displayPolicy;

  NodeDisplayPreferences({
    required this.displayPolicy,
  });

  @override
  int get hashCode => displayPolicy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeDisplayPreferences &&
          runtimeType == other.runtimeType &&
          displayPolicy == other.displayPolicy;
}

class StructureDesignerPreferences {
  final GeometryVisualizationPreferences geometryVisualizationPreferences;
  final NodeDisplayPreferences nodeDisplayPreferences;
  final AtomicStructureVisualizationPreferences
      atomicStructureVisualizationPreferences;

  const StructureDesignerPreferences.raw({
    required this.geometryVisualizationPreferences,
    required this.nodeDisplayPreferences,
    required this.atomicStructureVisualizationPreferences,
  });

  StructureDesignerPreferences cloneSelf() => RustLib.instance.api
          .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesCloneSelf(
        that: this,
      );

  factory StructureDesignerPreferences() => RustLib.instance.api
      .crateApiStructureDesignerStructureDesignerPreferencesStructureDesignerPreferencesNew();

  @override
  int get hashCode =>
      geometryVisualizationPreferences.hashCode ^
      nodeDisplayPreferences.hashCode ^
      atomicStructureVisualizationPreferences.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StructureDesignerPreferences &&
          runtimeType == other.runtimeType &&
          geometryVisualizationPreferences ==
              other.geometryVisualizationPreferences &&
          nodeDisplayPreferences == other.nodeDisplayPreferences &&
          atomicStructureVisualizationPreferences ==
              other.atomicStructureVisualizationPreferences;
}
