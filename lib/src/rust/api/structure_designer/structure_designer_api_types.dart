// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../common_api_types.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `hash`

class APIAtomCutData {
  final double cutSdfValue;
  final double unitCellSize;

  const APIAtomCutData({
    required this.cutSdfValue,
    required this.unitCellSize,
  });

  @override
  int get hashCode => cutSdfValue.hashCode ^ unitCellSize.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAtomCutData &&
          runtimeType == other.runtimeType &&
          cutSdfValue == other.cutSdfValue &&
          unitCellSize == other.unitCellSize;
}

class APIAtomEditData {
  final APIAtomEditTool activeTool;
  final int? bondToolLastAtomId;
  final int? replacementAtomicNumber;
  final int? addAtomToolAtomicNumber;
  final bool hasSelectedAtoms;
  final bool hasSelection;
  final APITransform? selectionTransform;
  final bool outputDiff;
  final bool showAnchorArrows;
  final bool includeBaseBondsInDiff;
  final APIDiffStats diffStats;

  const APIAtomEditData({
    required this.activeTool,
    this.bondToolLastAtomId,
    this.replacementAtomicNumber,
    this.addAtomToolAtomicNumber,
    required this.hasSelectedAtoms,
    required this.hasSelection,
    this.selectionTransform,
    required this.outputDiff,
    required this.showAnchorArrows,
    required this.includeBaseBondsInDiff,
    required this.diffStats,
  });

  @override
  int get hashCode =>
      activeTool.hashCode ^
      bondToolLastAtomId.hashCode ^
      replacementAtomicNumber.hashCode ^
      addAtomToolAtomicNumber.hashCode ^
      hasSelectedAtoms.hashCode ^
      hasSelection.hashCode ^
      selectionTransform.hashCode ^
      outputDiff.hashCode ^
      showAnchorArrows.hashCode ^
      includeBaseBondsInDiff.hashCode ^
      diffStats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAtomEditData &&
          runtimeType == other.runtimeType &&
          activeTool == other.activeTool &&
          bondToolLastAtomId == other.bondToolLastAtomId &&
          replacementAtomicNumber == other.replacementAtomicNumber &&
          addAtomToolAtomicNumber == other.addAtomToolAtomicNumber &&
          hasSelectedAtoms == other.hasSelectedAtoms &&
          hasSelection == other.hasSelection &&
          selectionTransform == other.selectionTransform &&
          outputDiff == other.outputDiff &&
          showAnchorArrows == other.showAnchorArrows &&
          includeBaseBondsInDiff == other.includeBaseBondsInDiff &&
          diffStats == other.diffStats;
}

enum APIAtomEditTool {
  default_,
  addAtom,
  addBond,
  ;
}

class APIAtomFillData {
  final String parameterElementValueDefinition;
  final APIVec3 motifOffset;
  final bool hydrogenPassivation;
  final bool removeSingleBondAtomsBeforePassivation;
  final bool surfaceReconstruction;
  final bool invertPhase;
  final String? error;

  const APIAtomFillData({
    required this.parameterElementValueDefinition,
    required this.motifOffset,
    required this.hydrogenPassivation,
    required this.removeSingleBondAtomsBeforePassivation,
    required this.surfaceReconstruction,
    required this.invertPhase,
    this.error,
  });

  @override
  int get hashCode =>
      parameterElementValueDefinition.hashCode ^
      motifOffset.hashCode ^
      hydrogenPassivation.hashCode ^
      removeSingleBondAtomsBeforePassivation.hashCode ^
      surfaceReconstruction.hashCode ^
      invertPhase.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAtomFillData &&
          runtimeType == other.runtimeType &&
          parameterElementValueDefinition ==
              other.parameterElementValueDefinition &&
          motifOffset == other.motifOffset &&
          hydrogenPassivation == other.hydrogenPassivation &&
          removeSingleBondAtomsBeforePassivation ==
              other.removeSingleBondAtomsBeforePassivation &&
          surfaceReconstruction == other.surfaceReconstruction &&
          invertPhase == other.invertPhase &&
          error == other.error;
}

class APIAtomMoveData {
  final APIVec3 translation;

  const APIAtomMoveData({
    required this.translation,
  });

  @override
  int get hashCode => translation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAtomMoveData &&
          runtimeType == other.runtimeType &&
          translation == other.translation;
}

class APIAtomRotData {
  final double angle;
  final APIVec3 rotAxis;
  final APIVec3 pivotPoint;

  const APIAtomRotData({
    required this.angle,
    required this.rotAxis,
    required this.pivotPoint,
  });

  @override
  int get hashCode => angle.hashCode ^ rotAxis.hashCode ^ pivotPoint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAtomRotData &&
          runtimeType == other.runtimeType &&
          angle == other.angle &&
          rotAxis == other.rotAxis &&
          pivotPoint == other.pivotPoint;
}

class APIAtomTransData {
  final APIVec3 translation;
  final APIVec3 rotation;

  const APIAtomTransData({
    required this.translation,
    required this.rotation,
  });

  @override
  int get hashCode => translation.hashCode ^ rotation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIAtomTransData &&
          runtimeType == other.runtimeType &&
          translation == other.translation &&
          rotation == other.rotation;
}

class APIBoolData {
  final bool value;

  const APIBoolData({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIBoolData &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

class APICircleData {
  final APIIVec2 center;
  final int radius;

  const APICircleData({
    required this.center,
    required this.radius,
  });

  @override
  int get hashCode => center.hashCode ^ radius.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APICircleData &&
          runtimeType == other.runtimeType &&
          center == other.center &&
          radius == other.radius;
}

class APICommentData {
  final String label;
  final String text;
  final double width;
  final double height;

  const APICommentData({
    required this.label,
    required this.text,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode =>
      label.hashCode ^ text.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APICommentData &&
          runtimeType == other.runtimeType &&
          label == other.label &&
          text == other.text &&
          width == other.width &&
          height == other.height;
}

class APICuboidData {
  final APIIVec3 minCorner;
  final APIIVec3 extent;

  const APICuboidData({
    required this.minCorner,
    required this.extent,
  });

  @override
  int get hashCode => minCorner.hashCode ^ extent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APICuboidData &&
          runtimeType == other.runtimeType &&
          minCorner == other.minCorner &&
          extent == other.extent;
}

class APIDataType {
  final APIDataTypeBase dataTypeBase;
  final String? customDataType;
  final bool array;

  const APIDataType({
    required this.dataTypeBase,
    this.customDataType,
    required this.array,
  });

  @override
  int get hashCode =>
      dataTypeBase.hashCode ^ customDataType.hashCode ^ array.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIDataType &&
          runtimeType == other.runtimeType &&
          dataTypeBase == other.dataTypeBase &&
          customDataType == other.customDataType &&
          array == other.array;
}

enum APIDataTypeBase {
  none,
  bool,
  string,
  int,
  float,
  vec2,
  vec3,
  iVec2,
  iVec3,
  unitCell,
  drawingPlane,
  geometry2D,
  geometry,
  atomic,
  motif,
  custom,
  ;
}

class APIDiffStats {
  final int atomsAdded;
  final int atomsDeleted;
  final int atomsModified;
  final int bondsAdded;
  final int bondsDeleted;

  const APIDiffStats({
    required this.atomsAdded,
    required this.atomsDeleted,
    required this.atomsModified,
    required this.bondsAdded,
    required this.bondsDeleted,
  });

  @override
  int get hashCode =>
      atomsAdded.hashCode ^
      atomsDeleted.hashCode ^
      atomsModified.hashCode ^
      bondsAdded.hashCode ^
      bondsDeleted.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIDiffStats &&
          runtimeType == other.runtimeType &&
          atomsAdded == other.atomsAdded &&
          atomsDeleted == other.atomsDeleted &&
          atomsModified == other.atomsModified &&
          bondsAdded == other.bondsAdded &&
          bondsDeleted == other.bondsDeleted;
}

class APIDrawingPlaneData {
  final int maxMillerIndex;
  final APIIVec3 millerIndex;
  final APIIVec3 center;
  final int shift;
  final int subdivision;

  const APIDrawingPlaneData({
    required this.maxMillerIndex,
    required this.millerIndex,
    required this.center,
    required this.shift,
    required this.subdivision,
  });

  @override
  int get hashCode =>
      maxMillerIndex.hashCode ^
      millerIndex.hashCode ^
      center.hashCode ^
      shift.hashCode ^
      subdivision.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIDrawingPlaneData &&
          runtimeType == other.runtimeType &&
          maxMillerIndex == other.maxMillerIndex &&
          millerIndex == other.millerIndex &&
          center == other.center &&
          shift == other.shift &&
          subdivision == other.subdivision;
}

class APIEditAtomData {
  final APIEditAtomTool activeTool;
  final bool canUndo;
  final bool canRedo;
  final int? bondToolLastAtomId;
  final int? replacementAtomicNumber;
  final int? addAtomToolAtomicNumber;
  final bool hasSelectedAtoms;
  final bool hasSelection;
  final APITransform? selectionTransform;

  const APIEditAtomData({
    required this.activeTool,
    required this.canUndo,
    required this.canRedo,
    this.bondToolLastAtomId,
    this.replacementAtomicNumber,
    this.addAtomToolAtomicNumber,
    required this.hasSelectedAtoms,
    required this.hasSelection,
    this.selectionTransform,
  });

  @override
  int get hashCode =>
      activeTool.hashCode ^
      canUndo.hashCode ^
      canRedo.hashCode ^
      bondToolLastAtomId.hashCode ^
      replacementAtomicNumber.hashCode ^
      addAtomToolAtomicNumber.hashCode ^
      hasSelectedAtoms.hashCode ^
      hasSelection.hashCode ^
      selectionTransform.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIEditAtomData &&
          runtimeType == other.runtimeType &&
          activeTool == other.activeTool &&
          canUndo == other.canUndo &&
          canRedo == other.canRedo &&
          bondToolLastAtomId == other.bondToolLastAtomId &&
          replacementAtomicNumber == other.replacementAtomicNumber &&
          addAtomToolAtomicNumber == other.addAtomToolAtomicNumber &&
          hasSelectedAtoms == other.hasSelectedAtoms &&
          hasSelection == other.hasSelection &&
          selectionTransform == other.selectionTransform;
}

enum APIEditAtomTool {
  default_,
  addAtom,
  addBond,
  ;
}

class APIExportXYZData {
  final String fileName;

  const APIExportXYZData({
    required this.fileName,
  });

  @override
  int get hashCode => fileName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIExportXYZData &&
          runtimeType == other.runtimeType &&
          fileName == other.fileName;
}

class APIExprData {
  final List<APIExprParameter> parameters;
  final String expression;
  final String? error;
  final APIDataType? outputType;

  const APIExprData({
    required this.parameters,
    required this.expression,
    this.error,
    this.outputType,
  });

  @override
  int get hashCode =>
      parameters.hashCode ^
      expression.hashCode ^
      error.hashCode ^
      outputType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIExprData &&
          runtimeType == other.runtimeType &&
          parameters == other.parameters &&
          expression == other.expression &&
          error == other.error &&
          outputType == other.outputType;
}

class APIExprParameter {
  final String name;
  final APIDataType dataType;

  const APIExprParameter({
    required this.name,
    required this.dataType,
  });

  @override
  int get hashCode => name.hashCode ^ dataType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIExprParameter &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dataType == other.dataType;
}

class APIExtrudeData {
  final int height;
  final APIIVec3 extrudeDirection;
  final bool infinite;
  final int subdivision;

  const APIExtrudeData({
    required this.height,
    required this.extrudeDirection,
    required this.infinite,
    required this.subdivision,
  });

  @override
  int get hashCode =>
      height.hashCode ^
      extrudeDirection.hashCode ^
      infinite.hashCode ^
      subdivision.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIExtrudeData &&
          runtimeType == other.runtimeType &&
          height == other.height &&
          extrudeDirection == other.extrudeDirection &&
          infinite == other.infinite &&
          subdivision == other.subdivision;
}

class APIFacet {
  final APIIVec3 millerIndex;
  final int shift;
  final bool symmetrize;
  final bool visible;

  const APIFacet({
    required this.millerIndex,
    required this.shift,
    required this.symmetrize,
    required this.visible,
  });

  @override
  int get hashCode =>
      millerIndex.hashCode ^
      shift.hashCode ^
      symmetrize.hashCode ^
      visible.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIFacet &&
          runtimeType == other.runtimeType &&
          millerIndex == other.millerIndex &&
          shift == other.shift &&
          symmetrize == other.symmetrize &&
          visible == other.visible;
}

class APIFacetShellData {
  final int maxMillerIndex;
  final APIIVec3 center;
  final List<APIFacet> facets;
  final BigInt? selectedFacetIndex;

  const APIFacetShellData({
    required this.maxMillerIndex,
    required this.center,
    required this.facets,
    this.selectedFacetIndex,
  });

  @override
  int get hashCode =>
      maxMillerIndex.hashCode ^
      center.hashCode ^
      facets.hashCode ^
      selectedFacetIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIFacetShellData &&
          runtimeType == other.runtimeType &&
          maxMillerIndex == other.maxMillerIndex &&
          center == other.center &&
          facets == other.facets &&
          selectedFacetIndex == other.selectedFacetIndex;
}

class APIFloatData {
  final double value;

  const APIFloatData({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIFloatData &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

class APIGeoTransData {
  final APIIVec3 translation;
  final APIIVec3 rotation;
  final bool transformOnlyFrame;

  const APIGeoTransData({
    required this.translation,
    required this.rotation,
    required this.transformOnlyFrame,
  });

  @override
  int get hashCode =>
      translation.hashCode ^ rotation.hashCode ^ transformOnlyFrame.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIGeoTransData &&
          runtimeType == other.runtimeType &&
          translation == other.translation &&
          rotation == other.rotation &&
          transformOnlyFrame == other.transformOnlyFrame;
}

class APIHalfPlaneData {
  final APIIVec2 point1;
  final APIIVec2 point2;

  const APIHalfPlaneData({
    required this.point1,
    required this.point2,
  });

  @override
  int get hashCode => point1.hashCode ^ point2.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIHalfPlaneData &&
          runtimeType == other.runtimeType &&
          point1 == other.point1 &&
          point2 == other.point2;
}

class APIHalfSpaceData {
  final int maxMillerIndex;
  final APIIVec3 millerIndex;
  final APIIVec3 center;
  final int shift;
  final int subdivision;

  const APIHalfSpaceData({
    required this.maxMillerIndex,
    required this.millerIndex,
    required this.center,
    required this.shift,
    required this.subdivision,
  });

  @override
  int get hashCode =>
      maxMillerIndex.hashCode ^
      millerIndex.hashCode ^
      center.hashCode ^
      shift.hashCode ^
      subdivision.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIHalfSpaceData &&
          runtimeType == other.runtimeType &&
          maxMillerIndex == other.maxMillerIndex &&
          millerIndex == other.millerIndex &&
          center == other.center &&
          shift == other.shift &&
          subdivision == other.subdivision;
}

class APIImportXYZData {
  final String? fileName;

  const APIImportXYZData({
    this.fileName,
  });

  @override
  int get hashCode => fileName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIImportXYZData &&
          runtimeType == other.runtimeType &&
          fileName == other.fileName;
}

class APIIntData {
  final int value;

  const APIIntData({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIIntData &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

class APILatticeMoveData {
  final APIIVec3 translation;
  final int latticeSubdivision;

  const APILatticeMoveData({
    required this.translation,
    required this.latticeSubdivision,
  });

  @override
  int get hashCode => translation.hashCode ^ latticeSubdivision.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APILatticeMoveData &&
          runtimeType == other.runtimeType &&
          translation == other.translation &&
          latticeSubdivision == other.latticeSubdivision;
}

class APILatticeRotData {
  final int? axisIndex;
  final int step;
  final APIIVec3 pivotPoint;
  final List<APIRotationalSymmetry> rotationalSymmetries;
  final String crystalSystem;

  const APILatticeRotData({
    this.axisIndex,
    required this.step,
    required this.pivotPoint,
    required this.rotationalSymmetries,
    required this.crystalSystem,
  });

  @override
  int get hashCode =>
      axisIndex.hashCode ^
      step.hashCode ^
      pivotPoint.hashCode ^
      rotationalSymmetries.hashCode ^
      crystalSystem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APILatticeRotData &&
          runtimeType == other.runtimeType &&
          axisIndex == other.axisIndex &&
          step == other.step &&
          pivotPoint == other.pivotPoint &&
          rotationalSymmetries == other.rotationalSymmetries &&
          crystalSystem == other.crystalSystem;
}

class APILatticeSymopData {
  final APIIVec3 translation;
  final APIVec3? rotationAxis;
  final double rotationAngleDegrees;
  final bool transformOnlyFrame;
  final List<APIRotationalSymmetry> rotationalSymmetries;
  final String crystalSystem;

  const APILatticeSymopData({
    required this.translation,
    this.rotationAxis,
    required this.rotationAngleDegrees,
    required this.transformOnlyFrame,
    required this.rotationalSymmetries,
    required this.crystalSystem,
  });

  @override
  int get hashCode =>
      translation.hashCode ^
      rotationAxis.hashCode ^
      rotationAngleDegrees.hashCode ^
      transformOnlyFrame.hashCode ^
      rotationalSymmetries.hashCode ^
      crystalSystem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APILatticeSymopData &&
          runtimeType == other.runtimeType &&
          translation == other.translation &&
          rotationAxis == other.rotationAxis &&
          rotationAngleDegrees == other.rotationAngleDegrees &&
          transformOnlyFrame == other.transformOnlyFrame &&
          rotationalSymmetries == other.rotationalSymmetries &&
          crystalSystem == other.crystalSystem;
}

class APIMapData {
  final APIDataType inputType;
  final APIDataType outputType;

  const APIMapData({
    required this.inputType,
    required this.outputType,
  });

  @override
  int get hashCode => inputType.hashCode ^ outputType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIMapData &&
          runtimeType == other.runtimeType &&
          inputType == other.inputType &&
          outputType == other.outputType;
}

/// Freeze mode for atom_edit energy minimization.
enum APIMinimizeFreezeMode {
  /// Only diff atoms move; base atoms are frozen.
  freezeBase,

  /// All atoms move freely.
  freeAll,

  /// Only selected atoms move; everything else is frozen.
  freeSelected,
  ;
}

class APIMotifData {
  final String definition;
  final String? name;
  final String? error;

  const APIMotifData({
    required this.definition,
    this.name,
    this.error,
  });

  @override
  int get hashCode => definition.hashCode ^ name.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIMotifData &&
          runtimeType == other.runtimeType &&
          definition == other.definition &&
          name == other.name &&
          error == other.error;
}

class APINetworkWithValidationErrors {
  final String name;
  final String? validationErrors;

  const APINetworkWithValidationErrors({
    required this.name,
    this.validationErrors,
  });

  @override
  int get hashCode => name.hashCode ^ validationErrors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APINetworkWithValidationErrors &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          validationErrors == other.validationErrors;
}

class APINodeCategoryView {
  final NodeTypeCategory category;
  final List<APINodeTypeView> nodes;

  const APINodeCategoryView({
    required this.category,
    required this.nodes,
  });

  @override
  int get hashCode => category.hashCode ^ nodes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APINodeCategoryView &&
          runtimeType == other.runtimeType &&
          category == other.category &&
          nodes == other.nodes;
}

/// Result of evaluating a single node via CLI
class APINodeEvaluationResult {
  /// The node ID that was evaluated
  final BigInt nodeId;

  /// The node type name (e.g., "cuboid", "atom_fill")
  final String nodeTypeName;

  /// The custom name if assigned, otherwise None
  final String? customName;

  /// The output data type name (e.g., "Geometry", "Atomic", "Float")
  final String outputType;

  /// Brief display string (from to_display_string())
  final String displayString;

  /// Detailed string (from to_detailed_string()), only populated if verbose=true
  final String? detailedString;

  /// Whether the evaluation succeeded (no errors in this node's chain)
  final bool success;

  /// Error message if the node itself produced an error
  final String? errorMessage;

  const APINodeEvaluationResult({
    required this.nodeId,
    required this.nodeTypeName,
    this.customName,
    required this.outputType,
    required this.displayString,
    this.detailedString,
    required this.success,
    this.errorMessage,
  });

  @override
  int get hashCode =>
      nodeId.hashCode ^
      nodeTypeName.hashCode ^
      customName.hashCode ^
      outputType.hashCode ^
      displayString.hashCode ^
      detailedString.hashCode ^
      success.hashCode ^
      errorMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APINodeEvaluationResult &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          nodeTypeName == other.nodeTypeName &&
          customName == other.customName &&
          outputType == other.outputType &&
          displayString == other.displayString &&
          detailedString == other.detailedString &&
          success == other.success &&
          errorMessage == other.errorMessage;
}

class APINodeTypeView {
  final String name;
  final String description;
  final String? summary;
  final NodeTypeCategory category;

  const APINodeTypeView({
    required this.name,
    required this.description,
    this.summary,
    required this.category,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      description.hashCode ^
      summary.hashCode ^
      category.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APINodeTypeView &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          summary == other.summary &&
          category == other.category;
}

class APIParameterData {
  final BigInt paramIndex;
  final String paramName;
  final APIDataType dataType;
  final int sortOrder;
  final String? error;

  const APIParameterData({
    required this.paramIndex,
    required this.paramName,
    required this.dataType,
    required this.sortOrder,
    this.error,
  });

  @override
  int get hashCode =>
      paramIndex.hashCode ^
      paramName.hashCode ^
      dataType.hashCode ^
      sortOrder.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIParameterData &&
          runtimeType == other.runtimeType &&
          paramIndex == other.paramIndex &&
          paramName == other.paramName &&
          dataType == other.dataType &&
          sortOrder == other.sortOrder &&
          error == other.error;
}

class APIRangeData {
  final int start;
  final int step;
  final int count;

  const APIRangeData({
    required this.start,
    required this.step,
    required this.count,
  });

  @override
  int get hashCode => start.hashCode ^ step.hashCode ^ count.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIRangeData &&
          runtimeType == other.runtimeType &&
          start == other.start &&
          step == other.step &&
          count == other.count;
}

class APIRectData {
  final APIIVec2 minCorner;
  final APIIVec2 extent;

  const APIRectData({
    required this.minCorner,
    required this.extent,
  });

  @override
  int get hashCode => minCorner.hashCode ^ extent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIRectData &&
          runtimeType == other.runtimeType &&
          minCorner == other.minCorner &&
          extent == other.extent;
}

class APIRegPolyData {
  final int numSides;
  final int radius;

  const APIRegPolyData({
    required this.numSides,
    required this.radius,
  });

  @override
  int get hashCode => numSides.hashCode ^ radius.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIRegPolyData &&
          runtimeType == other.runtimeType &&
          numSides == other.numSides &&
          radius == other.radius;
}

class APIRotationalSymmetry {
  final APIVec3 axis;
  final int nFold;

  const APIRotationalSymmetry({
    required this.axis,
    required this.nFold,
  });

  @override
  int get hashCode => axis.hashCode ^ nFold.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIRotationalSymmetry &&
          runtimeType == other.runtimeType &&
          axis == other.axis &&
          nFold == other.nFold;
}

class APISphereData {
  final APIIVec3 center;
  final int radius;

  const APISphereData({
    required this.center,
    required this.radius,
  });

  @override
  int get hashCode => center.hashCode ^ radius.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APISphereData &&
          runtimeType == other.runtimeType &&
          center == other.center &&
          radius == other.radius;
}

class APIStringData {
  final String value;

  const APIStringData({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIStringData &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

/// Result of applying text format edits to the active network.
class APITextEditResult {
  final bool success;
  final List<String> nodesCreated;
  final List<String> nodesUpdated;
  final List<String> nodesDeleted;
  final List<String> connectionsMade;
  final List<APITextError> errors;
  final List<String> warnings;

  const APITextEditResult({
    required this.success,
    required this.nodesCreated,
    required this.nodesUpdated,
    required this.nodesDeleted,
    required this.connectionsMade,
    required this.errors,
    required this.warnings,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      nodesCreated.hashCode ^
      nodesUpdated.hashCode ^
      nodesDeleted.hashCode ^
      connectionsMade.hashCode ^
      errors.hashCode ^
      warnings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APITextEditResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          nodesCreated == other.nodesCreated &&
          nodesUpdated == other.nodesUpdated &&
          nodesDeleted == other.nodesDeleted &&
          connectionsMade == other.connectionsMade &&
          errors == other.errors &&
          warnings == other.warnings;
}

/// A parse or edit error with location information.
class APITextError {
  final String message;
  final int line;
  final int column;

  const APITextError({
    required this.message,
    required this.line,
    required this.column,
  });

  @override
  int get hashCode => message.hashCode ^ line.hashCode ^ column.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APITextError &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          line == other.line &&
          column == other.column;
}

class APIUnitCellData {
  final double cellLengthA;
  final double cellLengthB;
  final double cellLengthC;
  final double cellAngleAlpha;
  final double cellAngleBeta;
  final double cellAngleGamma;
  final String crystalSystem;

  const APIUnitCellData({
    required this.cellLengthA,
    required this.cellLengthB,
    required this.cellLengthC,
    required this.cellAngleAlpha,
    required this.cellAngleBeta,
    required this.cellAngleGamma,
    required this.crystalSystem,
  });

  @override
  int get hashCode =>
      cellLengthA.hashCode ^
      cellLengthB.hashCode ^
      cellLengthC.hashCode ^
      cellAngleAlpha.hashCode ^
      cellAngleBeta.hashCode ^
      cellAngleGamma.hashCode ^
      crystalSystem.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIUnitCellData &&
          runtimeType == other.runtimeType &&
          cellLengthA == other.cellLengthA &&
          cellLengthB == other.cellLengthB &&
          cellLengthC == other.cellLengthC &&
          cellAngleAlpha == other.cellAngleAlpha &&
          cellAngleBeta == other.cellAngleBeta &&
          cellAngleGamma == other.cellAngleGamma &&
          crystalSystem == other.crystalSystem;
}

class APIVec2Data {
  final APIVec2 value;

  const APIVec2Data({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIVec2Data &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

class APIVec3Data {
  final APIVec3 value;

  const APIVec3Data({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIVec3Data &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

class APIIVec2Data {
  final APIIVec2 value;

  const APIIVec2Data({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIIVec2Data &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

class APIIVec3Data {
  final APIIVec3 value;

  const APIIVec3Data({
    required this.value,
  });

  @override
  int get hashCode => value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is APIIVec3Data &&
          runtimeType == other.runtimeType &&
          value == other.value;
}

/// Configuration for batch CLI runs
class BatchCliConfig {
  final String cnndFile;
  final String batchFile;

  const BatchCliConfig({
    required this.cnndFile,
    required this.batchFile,
  });

  @override
  int get hashCode => cnndFile.hashCode ^ batchFile.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BatchCliConfig &&
          runtimeType == other.runtimeType &&
          cnndFile == other.cnndFile &&
          batchFile == other.batchFile;
}

/// Configuration for single CLI run
class CliConfig {
  final String cnndFile;
  final String networkName;
  final String outputFile;

  /// Parameters as string key-value pairs (will be parsed based on parameter types)
  final Map<String, String> parameters;

  const CliConfig({
    required this.cnndFile,
    required this.networkName,
    required this.outputFile,
    required this.parameters,
  });

  @override
  int get hashCode =>
      cnndFile.hashCode ^
      networkName.hashCode ^
      outputFile.hashCode ^
      parameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CliConfig &&
          runtimeType == other.runtimeType &&
          cnndFile == other.cnndFile &&
          networkName == other.networkName &&
          outputFile == other.outputFile &&
          parameters == other.parameters;
}

/// Information for the factor-into-subnetwork dialog
class FactorSelectionInfo {
  /// Whether the selection can be factored
  final bool canFactor;

  /// If not valid, the reason why
  final String? invalidReason;

  /// Suggested name for the new subnetwork
  final String suggestedName;

  /// Suggested names for the parameters (one per external input)
  final List<String> suggestedParamNames;

  const FactorSelectionInfo({
    required this.canFactor,
    this.invalidReason,
    required this.suggestedName,
    required this.suggestedParamNames,
  });

  @override
  int get hashCode =>
      canFactor.hashCode ^
      invalidReason.hashCode ^
      suggestedName.hashCode ^
      suggestedParamNames.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FactorSelectionInfo &&
          runtimeType == other.runtimeType &&
          canFactor == other.canFactor &&
          invalidReason == other.invalidReason &&
          suggestedName == other.suggestedName &&
          suggestedParamNames == other.suggestedParamNames;
}

/// Request to factor selection into subnetwork
class FactorSelectionRequest {
  /// Name for the new subnetwork (custom node type)
  final String subnetworkName;

  /// Names for the parameters (must match count of external inputs)
  final List<String> paramNames;

  const FactorSelectionRequest({
    required this.subnetworkName,
    required this.paramNames,
  });

  @override
  int get hashCode => subnetworkName.hashCode ^ paramNames.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FactorSelectionRequest &&
          runtimeType == other.runtimeType &&
          subnetworkName == other.subnetworkName &&
          paramNames == other.paramNames;
}

/// Result of factoring attempt
class FactorSelectionResult {
  /// Whether the factoring succeeded
  final bool success;

  /// Error message if factoring failed
  final String? error;

  /// ID of the created custom node (if successful)
  final BigInt? newNodeId;

  const FactorSelectionResult({
    required this.success,
    this.error,
    this.newNodeId,
  });

  @override
  int get hashCode => success.hashCode ^ error.hashCode ^ newNodeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FactorSelectionResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          error == other.error &&
          newNodeId == other.newNodeId;
}

class InputPinView {
  final String name;
  final String dataType;
  final bool multi;

  const InputPinView({
    required this.name,
    required this.dataType,
    required this.multi,
  });

  @override
  int get hashCode => name.hashCode ^ dataType.hashCode ^ multi.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is InputPinView &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dataType == other.dataType &&
          multi == other.multi;
}

class NodeNetworkView {
  final String name;
  final Map<BigInt, NodeView> nodes;
  final List<WireView> wires;

  const NodeNetworkView({
    required this.name,
    required this.nodes,
    required this.wires,
  });

  @override
  int get hashCode => name.hashCode ^ nodes.hashCode ^ wires.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeNetworkView &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          nodes == other.nodes &&
          wires == other.wires;
}

enum NodeTypeCategory {
  annotation,
  mathAndProgramming,
  geometry2D,
  geometry3D,
  atomicStructure,
  otherBuiltin,
  custom,
  ;

  Future<void> displayName() => RustLib.instance.api
          .crateApiStructureDesignerStructureDesignerApiTypesNodeTypeCategoryDisplayName(
        that: this,
      );

  Future<int> order() => RustLib.instance.api
          .crateApiStructureDesignerStructureDesignerApiTypesNodeTypeCategoryOrder(
        that: this,
      );
}

class NodeView {
  final BigInt id;
  final String nodeTypeName;
  final String? customName;
  APIVec2 position;
  final List<InputPinView> inputPins;
  final String outputType;
  final String functionType;
  final bool selected;
  final bool active;
  final bool displayed;
  final bool returnNode;
  final String? error;
  final String? outputString;
  final String? subtitle;
  final String? commentLabel;
  final String? commentText;
  final double? commentWidth;
  final double? commentHeight;

  NodeView({
    required this.id,
    required this.nodeTypeName,
    this.customName,
    required this.position,
    required this.inputPins,
    required this.outputType,
    required this.functionType,
    required this.selected,
    required this.active,
    required this.displayed,
    required this.returnNode,
    this.error,
    this.outputString,
    this.subtitle,
    this.commentLabel,
    this.commentText,
    this.commentWidth,
    this.commentHeight,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      nodeTypeName.hashCode ^
      customName.hashCode ^
      position.hashCode ^
      inputPins.hashCode ^
      outputType.hashCode ^
      functionType.hashCode ^
      selected.hashCode ^
      active.hashCode ^
      displayed.hashCode ^
      returnNode.hashCode ^
      error.hashCode ^
      outputString.hashCode ^
      subtitle.hashCode ^
      commentLabel.hashCode ^
      commentText.hashCode ^
      commentWidth.hashCode ^
      commentHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeView &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          nodeTypeName == other.nodeTypeName &&
          customName == other.customName &&
          position == other.position &&
          inputPins == other.inputPins &&
          outputType == other.outputType &&
          functionType == other.functionType &&
          selected == other.selected &&
          active == other.active &&
          displayed == other.displayed &&
          returnNode == other.returnNode &&
          error == other.error &&
          outputString == other.outputString &&
          subtitle == other.subtitle &&
          commentLabel == other.commentLabel &&
          commentText == other.commentText &&
          commentWidth == other.commentWidth &&
          commentHeight == other.commentHeight;
}

/// Wire identifier for batch selection operations
class WireIdentifier {
  final BigInt sourceNodeId;
  final int sourceOutputPinIndex;
  final BigInt destinationNodeId;
  final BigInt destinationArgumentIndex;

  const WireIdentifier({
    required this.sourceNodeId,
    required this.sourceOutputPinIndex,
    required this.destinationNodeId,
    required this.destinationArgumentIndex,
  });

  @override
  int get hashCode =>
      sourceNodeId.hashCode ^
      sourceOutputPinIndex.hashCode ^
      destinationNodeId.hashCode ^
      destinationArgumentIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WireIdentifier &&
          runtimeType == other.runtimeType &&
          sourceNodeId == other.sourceNodeId &&
          sourceOutputPinIndex == other.sourceOutputPinIndex &&
          destinationNodeId == other.destinationNodeId &&
          destinationArgumentIndex == other.destinationArgumentIndex;
}

class WireView {
  final BigInt sourceNodeId;
  final int sourceOutputPinIndex;
  final BigInt destNodeId;
  final BigInt destParamIndex;
  final bool selected;

  const WireView({
    required this.sourceNodeId,
    required this.sourceOutputPinIndex,
    required this.destNodeId,
    required this.destParamIndex,
    required this.selected,
  });

  @override
  int get hashCode =>
      sourceNodeId.hashCode ^
      sourceOutputPinIndex.hashCode ^
      destNodeId.hashCode ^
      destParamIndex.hashCode ^
      selected.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WireView &&
          runtimeType == other.runtimeType &&
          sourceNodeId == other.sourceNodeId &&
          sourceOutputPinIndex == other.sourceOutputPinIndex &&
          destNodeId == other.destNodeId &&
          destParamIndex == other.destParamIndex &&
          selected == other.selected;
}
