// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'api_types.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `add_sample_model`, `add_sample_network`, `from_api_ivec3`, `from_api_transform`, `from_api_vec2`, `from_api_vec3`, `generate_mock_image`, `initialize_cad_instance_async`, `refresh_renderer`, `send_texture`, `to_api_ivec3`, `to_api_transform`, `to_api_vec2`, `to_api_vec3`
// These types are ignored because they are not used by any `pub` functions: `CADInstance`, `RGBA_FUNCTION`, `TEXTURE_RGBA_RENDERER_PLUGIN`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `deref`, `initialize`, `initialize`

/// Set the viewport size for rendering
Future<void> setViewportSize({required int width, required int height}) =>
    RustLib.instance.api
        .crateApiSimpleSetViewportSize(width: width, height: height);

void setActiveEditor({required Editor editor}) =>
    RustLib.instance.api.crateApiSimpleSetActiveEditor(editor: editor);

double provideTexture({required int texturePtr}) =>
    RustLib.instance.api.crateApiSimpleProvideTexture(texturePtr: texturePtr);

APICamera? getCamera() => RustLib.instance.api.crateApiSimpleGetCamera();

void moveCamera(
        {required APIVec3 eye, required APIVec3 target, required APIVec3 up}) =>
    RustLib.instance.api
        .crateApiSimpleMoveCamera(eye: eye, target: target, up: up);

void addAtom({required int atomicNumber, required APIVec3 position}) =>
    RustLib.instance.api
        .crateApiSimpleAddAtom(atomicNumber: atomicNumber, position: position);

APIVec3 findPivotPoint({required APIVec3 rayStart, required APIVec3 rayDir}) =>
    RustLib.instance.api
        .crateApiSimpleFindPivotPoint(rayStart: rayStart, rayDir: rayDir);

NodeNetworkView? getNodeNetworkView({required String nodeNetworkName}) =>
    RustLib.instance.api
        .crateApiSimpleGetNodeNetworkView(nodeNetworkName: nodeNetworkName);

void moveNode(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required APIVec2 position}) =>
    RustLib.instance.api.crateApiSimpleMoveNode(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId, position: position);

BigInt addNode(
        {required String nodeNetworkName,
        required String nodeTypeName,
        required APIVec2 position}) =>
    RustLib.instance.api.crateApiSimpleAddNode(
        nodeNetworkName: nodeNetworkName,
        nodeTypeName: nodeTypeName,
        position: position);

void connectNodes(
        {required String nodeNetworkName,
        required BigInt sourceNodeId,
        required BigInt destNodeId,
        required BigInt destParamIndex}) =>
    RustLib.instance.api.crateApiSimpleConnectNodes(
        nodeNetworkName: nodeNetworkName,
        sourceNodeId: sourceNodeId,
        destNodeId: destNodeId,
        destParamIndex: destParamIndex);

List<String>? getNodeTypeNames() =>
    RustLib.instance.api.crateApiSimpleGetNodeTypeNames();

void setNodeDisplay(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required bool isDisplayed}) =>
    RustLib.instance.api.crateApiSimpleSetNodeDisplay(
        nodeNetworkName: nodeNetworkName,
        nodeId: nodeId,
        isDisplayed: isDisplayed);

bool selectNode({required String nodeNetworkName, required BigInt nodeId}) =>
    RustLib.instance.api.crateApiSimpleSelectNode(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId);

bool selectWire(
        {required String nodeNetworkName,
        required BigInt sourceNodeId,
        required BigInt destinationNodeId,
        required BigInt destinationArgumentIndex}) =>
    RustLib.instance.api.crateApiSimpleSelectWire(
        nodeNetworkName: nodeNetworkName,
        sourceNodeId: sourceNodeId,
        destinationNodeId: destinationNodeId,
        destinationArgumentIndex: destinationArgumentIndex);

void clearSelection({required String nodeNetworkName}) => RustLib.instance.api
    .crateApiSimpleClearSelection(nodeNetworkName: nodeNetworkName);

APICuboidData? getCuboidData(
        {required String nodeNetworkName, required BigInt nodeId}) =>
    RustLib.instance.api.crateApiSimpleGetCuboidData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId);

APISphereData? getSphereData(
        {required String nodeNetworkName, required BigInt nodeId}) =>
    RustLib.instance.api.crateApiSimpleGetSphereData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId);

APIHalfSpaceData? getHalfSpaceData(
        {required String nodeNetworkName, required BigInt nodeId}) =>
    RustLib.instance.api.crateApiSimpleGetHalfSpaceData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId);

APIGeoTransData? getGeoTransData(
        {required String nodeNetworkName, required BigInt nodeId}) =>
    RustLib.instance.api.crateApiSimpleGetGeoTransData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId);

APIAtomTransData? getAtomTransData(
        {required String nodeNetworkName, required BigInt nodeId}) =>
    RustLib.instance.api.crateApiSimpleGetAtomTransData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId);

void setCuboidData(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required APICuboidData data}) =>
    RustLib.instance.api.crateApiSimpleSetCuboidData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId, data: data);

void setSphereData(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required APISphereData data}) =>
    RustLib.instance.api.crateApiSimpleSetSphereData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId, data: data);

void setHalfSpaceData(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required APIHalfSpaceData data}) =>
    RustLib.instance.api.crateApiSimpleSetHalfSpaceData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId, data: data);

void setGeoTransData(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required APIGeoTransData data}) =>
    RustLib.instance.api.crateApiSimpleSetGeoTransData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId, data: data);

void setAtomTransData(
        {required String nodeNetworkName,
        required BigInt nodeId,
        required APIAtomTransData data}) =>
    RustLib.instance.api.crateApiSimpleSetAtomTransData(
        nodeNetworkName: nodeNetworkName, nodeId: nodeId, data: data);

void deleteSelected({required String nodeNetworkName}) => RustLib.instance.api
    .crateApiSimpleDeleteSelected(nodeNetworkName: nodeNetworkName);

int? gadgetHitTest(
        {required APIVec3 rayOrigin, required APIVec3 rayDirection}) =>
    RustLib.instance.api.crateApiSimpleGadgetHitTest(
        rayOrigin: rayOrigin, rayDirection: rayDirection);

void gadgetStartDrag(
        {required String nodeNetworkName,
        required int handleIndex,
        required APIVec3 rayOrigin,
        required APIVec3 rayDirection}) =>
    RustLib.instance.api.crateApiSimpleGadgetStartDrag(
        nodeNetworkName: nodeNetworkName,
        handleIndex: handleIndex,
        rayOrigin: rayOrigin,
        rayDirection: rayDirection);

void gadgetDrag(
        {required String nodeNetworkName,
        required int handleIndex,
        required APIVec3 rayOrigin,
        required APIVec3 rayDirection}) =>
    RustLib.instance.api.crateApiSimpleGadgetDrag(
        nodeNetworkName: nodeNetworkName,
        handleIndex: handleIndex,
        rayOrigin: rayOrigin,
        rayDirection: rayDirection);

void gadgetEndDrag({required String nodeNetworkName}) => RustLib.instance.api
    .crateApiSimpleGadgetEndDrag(nodeNetworkName: nodeNetworkName);

bool syncGadgetData({required String nodeNetworkName}) => RustLib.instance.api
    .crateApiSimpleSyncGadgetData(nodeNetworkName: nodeNetworkName);

void importXyz({required String filePath}) =>
    RustLib.instance.api.crateApiSimpleImportXyz(filePath: filePath);

bool exportXyz({required String filePath}) =>
    RustLib.instance.api.crateApiSimpleExportXyz(filePath: filePath);

BigInt? selectClusterByRay(
        {required APIVec3 rayStart,
        required APIVec3 rayDir,
        required SelectModifier selectModifier}) =>
    RustLib.instance.api.crateApiSimpleSelectClusterByRay(
        rayStart: rayStart, rayDir: rayDir, selectModifier: selectModifier);

void selectClusterById(
        {required BigInt clusterId, required SelectModifier selectModifier}) =>
    RustLib.instance.api.crateApiSimpleSelectClusterById(
        clusterId: clusterId, selectModifier: selectModifier);

SceneComposerView? getSceneComposerView() =>
    RustLib.instance.api.crateApiSimpleGetSceneComposerView();

APITransform? getSelectedFrameTransform() =>
    RustLib.instance.api.crateApiSimpleGetSelectedFrameTransform();

void setSelectedFrameTransform({required APITransform transform}) =>
    RustLib.instance.api
        .crateApiSimpleSetSelectedFrameTransform(transform: transform);

APITransform getCameraTransform() =>
    RustLib.instance.api.crateApiSimpleGetCameraTransform();

void setCameraTransform({required APITransform transform}) =>
    RustLib.instance.api.crateApiSimpleSetCameraTransform(transform: transform);

void translateAlongLocalAxis(
        {required int axisIndex, required double translation}) =>
    RustLib.instance.api.crateApiSimpleTranslateAlongLocalAxis(
        axisIndex: axisIndex, translation: translation);

void rotateAroundLocalAxis(
        {required int axisIndex, required double angleDegrees}) =>
    RustLib.instance.api.crateApiSimpleRotateAroundLocalAxis(
        axisIndex: axisIndex, angleDegrees: angleDegrees);

bool isFrameLockedToAtoms() =>
    RustLib.instance.api.crateApiSimpleIsFrameLockedToAtoms();

void setFrameLockedToAtoms({required bool locked}) =>
    RustLib.instance.api.crateApiSimpleSetFrameLockedToAtoms(locked: locked);

BigInt? selectAlignAtomByRay(
        {required APIVec3 rayStart, required APIVec3 rayDir}) =>
    RustLib.instance.api
        .crateApiSimpleSelectAlignAtomByRay(rayStart: rayStart, rayDir: rayDir);

void setActiveSceneComposerTool({required APISceneComposerTool tool}) =>
    RustLib.instance.api.crateApiSimpleSetActiveSceneComposerTool(tool: tool);

String getAlignToolStateText() =>
    RustLib.instance.api.crateApiSimpleGetAlignToolStateText();

String getDistanceToolStateText() =>
    RustLib.instance.api.crateApiSimpleGetDistanceToolStateText();

BigInt? selectAtomInfoAtomByRay(
        {required APIVec3 rayStart, required APIVec3 rayDir}) =>
    RustLib.instance.api.crateApiSimpleSelectAtomInfoAtomByRay(
        rayStart: rayStart, rayDir: rayDir);

AtomView? getSceneComposerAtomInfo() =>
    RustLib.instance.api.crateApiSimpleGetSceneComposerAtomInfo();

BigInt? selectDistanceAtomByRay(
        {required APIVec3 rayStart, required APIVec3 rayDir}) =>
    RustLib.instance.api.crateApiSimpleSelectDistanceAtomByRay(
        rayStart: rayStart, rayDir: rayDir);

void sceneComposerNewModel() =>
    RustLib.instance.api.crateApiSimpleSceneComposerNewModel();

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);
