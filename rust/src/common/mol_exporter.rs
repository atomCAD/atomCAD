use std::fs::File;
use std::io::{self, Write};
use thiserror::Error;
use crate::common::atomic_structure::AtomicStructure;
use crate::common::common_constants::ATOM_INFO;

#[derive(Debug, Error)]
pub enum MolSaveError {
    #[error("I/O error: {0}")]
    Io(#[from] io::Error),
    
    #[error("Element not found for atomic number: {0}")]
    ElementNotFound(i32),
}

/// Saves an AtomicStructure to a MOL file in V3000 format
///
/// # Arguments
///
/// * `atomic_structure` - The atomic structure to save
/// * `file_path` - The path where the MOL file should be saved
///
/// # Returns
///
/// * `Result<(), MolSaveError>` - Ok(()) if successful, or an error if the operation fails
pub fn save_mol_v3000(atomic_structure: &AtomicStructure, file_path: &str) -> Result<(), MolSaveError> {
    let mut file = File::create(file_path)?;
    
    let num_atoms = atomic_structure.get_num_of_atoms();
    let num_bonds = atomic_structure.get_num_of_bonds();
    
    // Get title from file name
    let title = std::path::Path::new(file_path)
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("Exported from atomCAD");
    
    // Write header (3 lines)
    writeln!(file, "{}", title)?;
    writeln!(file, "atomCAD 1.0")?;
    writeln!(file, "Generated by atomCAD")?;
    
    // Write legacy counts line with V3000 token
    writeln!(file, "  0  0  0  0  0  0            999 V3000")?;
    
    // Begin CTAB block
    writeln!(file, "M  V30 BEGIN CTAB")?;
    writeln!(file, "M  V30 COUNTS {} {} 0 0 0", num_atoms, num_bonds)?;
    
    // Write atoms
    writeln!(file, "M  V30 BEGIN ATOM")?;
    
    // Create a mapping from atom IDs to 1-based indices
    let mut atom_id_to_index = std::collections::HashMap::new();
    let mut index = 1;
    
    // Sort atoms by ID for consistent output
    let mut sorted_atoms: Vec<_> = atomic_structure.atoms.iter().collect();
    sorted_atoms.sort_by_key(|(id, _)| *id);
    
    for (atom_id, atom) in sorted_atoms {
        // Get element symbol from atomic number
        let atom_info = ATOM_INFO
            .get(&atom.atomic_number)
            .ok_or_else(|| MolSaveError::ElementNotFound(atom.atomic_number))?;
        
        // Store the mapping for bond writing
        atom_id_to_index.insert(*atom_id, index);
        
        // Write atom line: M V30 <idx> <Element> <x> <y> <z> 0
        writeln!(
            file,
            "M  V30 {} {} {:.6} {:.6} {:.6} 0",
            index,
            atom_info.symbol,
            atom.position.x,
            atom.position.y,
            atom.position.z
        )?;
        
        index += 1;
    }
    
    writeln!(file, "M  V30 END ATOM")?;
    
    // Write bonds
    writeln!(file, "M  V30 BEGIN BOND")?;
    
    // Sort bonds by ID for consistent output
    let mut sorted_bonds: Vec<_> = atomic_structure.bonds.iter().collect();
    sorted_bonds.sort_by_key(|(id, _)| *id);
    
    let mut bond_index = 1;
    for (_, bond) in sorted_bonds {
        // Get 1-based indices for the atoms
        let atom1_index = atom_id_to_index.get(&bond.atom_id1)
            .ok_or_else(|| MolSaveError::ElementNotFound(0))?; // Using 0 as placeholder for missing atom
        let atom2_index = atom_id_to_index.get(&bond.atom_id2)
            .ok_or_else(|| MolSaveError::ElementNotFound(0))?; // Using 0 as placeholder for missing atom
        
        // Write bond line: M V30 <bidx> <btype> <a1> <a2>
        writeln!(
            file,
            "M  V30 {} {} {} {}",
            bond_index,
            bond.multiplicity,
            atom1_index,
            atom2_index
        )?;
        
        bond_index += 1;
    }
    
    writeln!(file, "M  V30 END BOND")?;
    
    // End CTAB block
    writeln!(file, "M  V30 END CTAB")?;
    writeln!(file, "M  END")?;
    
    Ok(())
}